<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Object with Three.js</title>
    <link rel="stylesheet" type="text/css" href="assets/css.css">
    <link rel="preload" as="fetch" href="./assets/helmet/scene.gltf" fetchpriority="high">
    <link rel="preload" as="fetch" href="./assets/astronaut/scene.gltf" fetchpriority="high">

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            z-index: 1000;
        }

        #content {
            display: none;
        }
    </style>
</head>

<body>
    <div id="loader">Loading...</div>
    <div id="content">
        <p id="nico">Nico Escovilla</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        async function preloadGLTF(url) {
            try {
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Failed to load ${url}`);
                }
                await response.blob(); // Ensure the file is fully loaded
                return true;
            } catch (error) {
                console.error(error);
                return false;
            }
        }

        async function init() {
            const loaderElement = document.getElementById('loader');
            const contentElement = document.getElementById('content');

            // Preload both models
            const helmetLoaded = await preloadGLTF('./assets/helmet/scene.gltf');
            const astronautLoaded = await preloadGLTF('./assets/astronaut/scene.gltf');

            if (helmetLoaded && astronautLoaded) {
                loaderElement.style.display = 'none';
                contentElement.style.display = 'block';
                startScene(); // Start the Three.js rendering and animations
            } else {
                loaderElement.textContent = 'Failed to load content.';
            }
        }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('assets/sw.js').then(() => {
                console.log('Service Worker registered');
            });
        }
        function startScene() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.27, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const redLight = new THREE.PointLight(0xff0000, 30, 1100);
            redLight.position.set(0, 20, 10);
            scene.add(redLight);

            const blueLightRight = new THREE.PointLight(0xff0000, 90, 1100);
            blueLightRight.position.set(10, -10, 10);
            scene.add(blueLightRight);

            const l2 = new THREE.PointLight(0x0000ff, .9);
            l2.position.set(1.2, 2, 0);
            scene.add(l2);

            // Models



            const light = new THREE.PointLight(0xff0000, 0, 0); // Blue light, intensity 1

            light.position.set(1.2, 4, 0);
            scene.add(light);

            function startFlicker() {
                const flickerDuration = 500; // Flicker lasts 500ms
                const flickerInterval = 100; // Flicker happens quickly within the 500ms

                let flickerCount = 0;
                const maxFlickers = flickerDuration / flickerInterval;

                // Temporary flickering effect
                const flickerTimer = setInterval(() => {
                    light.intensity = Math.random() * 3.9; // Randomize light intensity
                    flickerCount++;

                    if (flickerCount >= maxFlickers) {
                        clearInterval(flickerTimer);
                        light.intensity = 0; // Reset to original intensity
                    }
                }, flickerInterval);
            }

            // Trigger flicker every 5 seconds
            let intervalId; // Variable to store the interval ID

            const nicoElement = document.querySelector("#nico");

            // Function to start the flicker interval
            let play = 0
            function startFlickerInterval() {
                intervalId = setInterval(() => {
                    if (play == 0) {
                        console.log("startFlickerInterval")
                        startFlicker(); // Trigger Three.js flicker
                        nicoElement.style.animation = "none"; // Restart animation
                        void nicoElement.offsetWidth; // Trigger reflow to reset animation
                        nicoElement.style.animation = "flicker 0.5s steps(2, start)";
                    }

                }, 5000);
            }

            // Function to stop the flicker interval

            function stopFlickerInterval() {

                void nicoElement.offsetWidth;
                console.log("stopFlickerInterval")
                nicoElement.style.animation = "none !important";
                clearInterval(intervalId);
            }

            // Start the interval initially
            startFlickerInterval();

            // Event listener to toggle animation and apply blur
            nicoElement.addEventListener("click", () => {
                // Stop the flicker animation
                play = 1
                void nicoElement.offsetWidth;
                stopFlickerInterval();
                // Apply a blur effect to the renderer with a smooth transition
                renderer.domElement.style.transition = "filter 1s ease"; // Transition over 1 second
                renderer.domElement.style.filter = "blur(10px)"; // Apply blur

                // Optional: remove the blur after a delay (e.g., 2 seconds)
                setTimeout(() => {
                    renderer.domElement.style.filter = "none"; // Remove blur
                    nicoElement.style.animation = "none"; // Restart animation
                    void nicoElement.offsetWidth; // Trigger reflow to reset animation
                    startFlickerInterval(); // Restart the flicker effect after blur

                }, 3000);

                // Apply a transition to the text's clarity
                nicoElement.style.transition = "color 1s ease, text-shadow 1s ease"; // Transition over 1 second
                nicoElement.style.textShadow = "-5px 0px 0px rgb(104 0 0)"; // Change text-shadow for effect

                // Optionally revert back to original state after a delay (e.g., 2 seconds)
                setTimeout(() => {
                    nicoElement.style.color = "#00000000"; // Restore original transparent color
                    nicoElement.style.textShadow = "-5px 0px 10px rgb(104 0 0)"; // Restore original shadow
                    play = 0;
                }, 3000);

                console.log(play)
            });



            window.addEventListener("load", () => {
                const nicoElement = document.querySelector("#nico");
                setTimeout(() => {
                    nicoElement.style.opacity = "1"; // Make it visible
                    nicoElement.style.opacity = "opacity 3s ease-in-out"; // Smooth fade-in
                    nicoElement.style.textShadow = "-5px 0px 0px rgb(104 0 0)";
                    nicoElement.style.transition = "color 1s ease, text-shadow 1s ease";
                    renderer.domElement.style.transition = "filter 1s ease"; // Transition over 1 second
                    renderer.domElement.style.filter = "blur(10px)";
                }, 3000); // Delay of 3 seconds
                setTimeout(() => {
                    renderer.domElement.style.filter = "none"; // Remove blur
                    nicoElement.style.animation = "none"; // Restart animation
                    void nicoElement.offsetWidth; // Trigger reflow to reset animation

                    startFlickerInterval();
                    nicoElement.style.textShadow = "-5px 0px 10px rgb(104 0 0)";
                }, 4500);
            });

            const loader = new THREE.GLTFLoader();
            let helmet, astronaut;
            let helmetBasePosition = new THREE.Vector3(); // Store base positions
            let astronautBasePosition = new THREE.Vector3();

            // Load Helmet Model
            loader.load(
                './assets/helmet/scene.gltf',
                function (gltf) {
                    helmet = gltf.scene;
                    scene.add(helmet);
                    helmetBasePosition.set(-2, -1, 0.009); // Set base position

                    helmet.position.copy(helmetBasePosition); // Apply base position
                    helmet.rotation.y = 0; // Rotate 180 degrees around Y-axis
                    helmet.rotation.x = 0
                    console.log("Helmet loaded and positioned:", helmetBasePosition);
                },
                undefined,
                function (error) {
                    console.error('An error occurred with helmet:', error);
                }
            );

            // Load Astronaut Model
            loader.load(
                './assets/astronaut/scene.gltf',
                function (gltf) {
                    astronaut = gltf.scene;
                    scene.add(astronaut);

                    // Set base position
                    astronautBasePosition.set(3.4, 2, 0);
                    astronaut.position.copy(astronautBasePosition);

                    // Set the astronaut to face forward (negative Z-axis)
                    astronaut.rotation.y = Math.PI + 18; // Rotate 180 degrees around Y-axis
                    astronaut.rotation.x = 10
                    console.log("Astronaut loaded, positioned, and rotated:", astronautBasePosition);
                },
                undefined,
                function (error) {
                    console.error('An error occurred with astronaut:', error);
                }
            );

            // Camera position
            camera.position.z = 3.7;

            // Animate the scene
            let helmetFloatOffset = 0;
            let astronautFloatOffset = 0;

            function animate() {
                requestAnimationFrame(animate);

                // If the helmet is loaded
                if (helmet) {
                    helmet.rotation.y += 0.0009; // Rotate
                    helmet.rotation.x += 0.0009;

                    // Oscillate around its base position
                    helmetFloatOffset += 0.001;
                    helmet.position.y = helmetBasePosition.y + Math.sin(helmetFloatOffset) * 0.1; // Float up and down
                }

                // If the astronaut is loaded
                if (astronaut) {
                    astronaut.rotation.y += 0.0009; // Slower rotation
                    astronaut.rotation.x += 0.0009;

                    // Oscillate around its base position
                    astronautFloatOffset += 0.0005;
                    astronaut.position.y = astronautBasePosition.y + Math.sin(astronautFloatOffset) * 0.0; // Float up and down
                    astronaut.position.x = astronautBasePosition.x + Math.sin(astronautFloatOffset) * 0.0; // Slight left/right movement
                }

                renderer.render(scene, camera);
            }

            animate();
        }

        init();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


    </script>
</body>

</html>